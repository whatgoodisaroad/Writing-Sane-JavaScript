\documentclass[11pt,letter]{book}
\usepackage[svgnames]{xcolor}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\begin{document}
    \title{Writing Sane JavaScript}
    \author{Wyatt Allen}
    \maketitle
    
    \chapter{Introduction}
    TODO: Title, History, Significance, Beauty, State, How to read
    
    \part{The Language}
    \chapter{The Type System}
    \section{Overview}
    JavaScript has a unique type system. In many ways it is Spartan. In many other ways 
    it is rich and expressive. In many, many other ways it is inconsistent and treacherous.
    In this chapter, you will be introduced to the type system from each of these three 
    angles.
    
    If you, the reader, gain a complete understanding of these types, it will either result 
    in true enjoyment of a unique and powerful system, or well-informed hatred of a tangled 
    mess. Read on to find out which it will be.
    
    \section{At a Fundamental Level}
    At a fundamental level JavaScript has four basic datatypes. There are three primitive 
    types which should be familiar to you as a programmer: \texttt{boolean}, \texttt{number} 
    and \texttt{string}. The fourth datatype is \texttt{object}, which may be thought of as a 
    composite type. Although the three primitives will behave largely in a similar 
    fashion to what you're used to in other languages, some of \texttt{object}'s nuances 
    may be surprising.
    
    Although I said there were only three, JavaScript actually defines two additional primitive 
    types: \texttt{null} and \texttt{undefined}. \texttt{null} will probably look familiar to 
    you from most any object-oriented language. \texttt{undefined} might be new to you. We'll 
    explore these types in greater detail (and see why they're very different from the other 
    primitives) once we've dug deeper into the type system. For now, just put them on your radar.
    
    It's important to note that the line between primitive and object is not so clearly defined
    in JavaScript as it is in other languages. You'll find that nearly any value in JavaScript can
    \emph{behave} like an object while remaining primitive. Some people interpret this to mean that
    \emph{every value} in JavaScript is an object in disguise, but this is not strictly the case.
    We'll look at objects very closely soon enough.
    
    \subsection{The \texttt{boolean} Datatype}
    If we restrict ourselves to the fundamentals of the type system, the \texttt{boolean} 
    datatype is as simple as can be. The ECMAScript standard explains it in a single sentence:
    
    \begin{quote}
        The Boolean type represents a logical entity having two values, called \textbf{true}
        and \textbf{false}.
    \end{quote}
    
    In practice, \texttt{true} and \texttt{false} are keywords which  statically refer to the two 
    possible boolean values (just as you find in most programming languages). These are considered 
    ``Boolean Literals.''
    
    Here are some examples of simple boolean values:
    
    \begin{verbatim}
    true
    
    false
    
    \end{verbatim}
    
    \subsection{The \texttt{number} Datatype}
    In JavaScript, there is no distinction between integral and floating-point numbers. Instead, 
    we're given a single, unified type: \texttt{number}.
    
    A number is stored as a signed 64-bit float according to the IEEE 754 standard. This means, 
    under the covers, the numbers you deal with in JavaScript have the same encoding constraints as 
    double-precision floats in Java or C.
    
    It is worth noting that the simplicity you get by having a unified type for numbers comes at 
    a cost of space-efficiency, performance and type-safety. On the other hand this will make 
    some of your code cleaner because you will no-longer need no coerce integers to floats or 
    worry about loss of precision in mixed-mode division. In general, we will find that 
    JavaScript tends to sacrifice efficiency/performance/safety in small ways in order to gain 
    in simplicity.
    
    A JavaScript number can be as large as $\pm 1.7976931348623157 \times 10^{308}$ or as small as
    $\pm 5 \times 10^{-324}$. The range of integral values which can be stored in a JavaScript 
    \texttt{number} is $\pm 2^{53}$.
    
    Numbers can be declared with number literals. Number literals can be base-10 or base-16 (using 
    the traditional \texttt{0x} prefix). In some implementations base-8 number literals are allowed 
    when the number is prefixed with a leading zero. Number literals can also be written with 
    exponential notation by suffixing a lower or upper-case letter ``e'' followed by a positive or 
    negative radix. 
    
    Negative number literals can be made in the usual way, by prefixing the literal with a minus 
    sign. However, this isn't actually part of the literal itself, but is an application of the 
    unary negation operator to the literal.
    
    Here are some examples of simple number values:
    
    \begin{verbatim}
    7
    
    42
    
    -512
    
    7.62
    
    6.022141e23
    
    6.6260695729E-34
    
    0xf0
    
    0xff63ba
    
    \end{verbatim}
    
    \subsection{The \texttt{string} Datatype}
    JavaScript provides \texttt{string} as a primitive type for dealing with text. All strings in 
    JavaScript are encoded using UTF-16.
    
    You just learned that JavaScript unifies integers and floats under numbers at a cost of 
    performance and for the sake of simplicity. With strings, JavaScript makes a similar 
    simplification: there is no \texttt{char} type. That is to say: in JavaScript any single 
    character is of type \texttt{string} with a string-length of 1. For dealing with  
    text, the \texttt{string} datatype is the only datatype you need.
    
    String literals must be delimited by matching single or double quotes. In other words, strings 
    may be delimited by either a matching start and end single quote or a matching start and end 
    double quote but not mixed. The quote type which is not used to delimit may be used within the 
    string literal without escaping.
    
    JavaScript \texttt{string}s support many of the escape sequences you're used to.
    
    \vspace{10pt}
    \small{
        \begin{tabular}{c|l}
            Sequence & Result \\
            \hline
            \texttt{\textbackslash{'}}  & A single quote. (\textbackslash{u0027}) \\
            \texttt{\textbackslash{"}}  & A double quote. (\textbackslash{u0022}) \\
            \texttt{\textbackslash\textbackslash} 
                                        & A backslash. (\textbackslash{u005c}) \\
            \texttt{\textbackslash{uXXXX}}
                                        & The unicode character represented by the hexadecimal
                                            digits XXXX. \\
            \texttt{\textbackslash{t}}  & A horizontal tab. (\textbackslash{u0009}) \\
            \texttt{\textbackslash{n}}  & A newline. (\textbackslash{u000a}) \\
        \end{tabular}
    }
    \vspace{10pt}
    
    Several other escape sequences are available, but are not useful in most JavaScript scenarios. 
    A full list of available escape sequences can be found in the appendix.
    
    Here are some examples of simple string values:
    
    \begin{verbatim}
    "Hello, world."
    
    'Hello, world with single quotes.'
    
    "This apostrophe needn't be escaped."
    
    'This apostrophe\'s escape is necessary.'
    
    'Double "quotes in single" quotes.'
    
    "Text\n spanning\n multiple\n lines"
    
    \end{verbatim}
    
    \subsection{The \texttt{object} Datatype}
    
    As stated above, the \texttt{object} datatype may be thought of as a composite of other 
    datatypes. In particular, an object is a collection of \emph{named data properties}, similar
    to a dictionary you may be familiar with from other languages.
    
    It is a remarkable feature of JavaScript that the \texttt{object} datatype also has a literal
    notation. The \texttt{object} is delimited by a pair of curly braces (i.e. ``\texttt{\{}'' and 
    ``\texttt{\}}''). Within these braces, a named data property is specified by its name, followed
    by a colon (i.e. \texttt{:}) followed by the property's data value. These named data properties
    must be separated by commas.
    
    As an example, the following is an object literal with two properties: a property named 
    \texttt{foo} with the value of the \texttt{number} \texttt{42} and another property named 
    \texttt{bar} with the value of the \texttt{string} \texttt{"hello, world"}.
    
    \begin{verbatim}
    { foo:42, bar:"hello, world" }
    
    \end{verbatim}
    
    The order of the properties within the object literal is insignificant.
    
    
    
    
    
    
    
\end{document}



