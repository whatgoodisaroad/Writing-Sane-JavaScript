\documentclass[11pt,letter]{book}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\usepackage[pdftex]{graphicx}

\begin{document}
    \begin{titlepage}

        \begin{center}
            { \huge \bfseries Writing Sane JavaScript}\\[0.4cm]
            
            \textsc{\Large A Comprehensive Introduction}\\[0.5cm]
            
            \textsc{Wyatt Allen}
            
            \HRule \\[2.2cm]
            
            \includegraphics[width=10cm]{socrates-hemlock}

            \vfill

        \end{center}

    \end{titlepage}
        
    \chapter{Introduction}
    \begin{quote}
        \emph{
            ...an interesting mix ... capable of such beautiful dreams and such horrible nightmares.
        } \\
        -- Carl Sagan, \emph{Contact}
    \end{quote}
    
    JavaScript is a truly remarkable language. It is ubiquitous: every computer with a browser 
    installed comes with a full runtime. It's uncommonly powerful: its dynamic nature is more 
    flexible than nearly any enterprise language, yet is used to do more and more amazing things.
    It's unstoppable: since it's halfhearted genesis in 1995 it's never slowed it's growing 
    popularity.
    
    Moreover, JavaScript is both beautiful and deeply flawed. The above quote from Carl Sagan 
    frequently visits me as I work on code, although it was originally written about an alien being 
    musing on the human race.
    
    TODO: Title, History, Significance, Beauty, State, How to read
    
    \part{The Language}
    \chapter{The Type System}
    \section{Overview}
    The key to mastering JavaScript is a complete understanding of the type system. In this chapter
    we will have a first look at each of the fundamental datatypes in JavaScript. We examine the 
    type system before presenting any code examples, so this chapter may seem a little dry. Let the 
    reader be ensured, however, that this approach is to provide a rich context for when we finally
    do get to code.
    
    JavaScript has a unique type system. In many ways it is Spartan. In many other ways 
    it is rich and expressive. In many, many other ways it is inconsistent and treacherous.
    Throughout this book, you will be introduced to the type system from each of these three 
    angles.
    
    If you, the reader, gain a complete understanding of these types, it will either result 
    in true enjoyment of a unique and powerful system, or well-informed hatred of a tangled 
    mess. Read on to find out which it will be.
    
    \section{Datatypes at a Fundamental Level}
    At a fundamental level JavaScript has four basic datatypes. There are three primitive 
    types which should be familiar to you as a programmer: \texttt{boolean}, \texttt{number} 
    and \texttt{string}. The fourth datatype is \texttt{object}, which may be thought of as a 
    composite type. Although the three primitives will behave largely in a similar 
    fashion to what you're used to in other languages, some of \texttt{object}'s nuances 
    may be surprising.
    
    Although I said there were only three, JavaScript actually defines two additional types: which
    are technically primitive also, \texttt{null} and \texttt{undefined}. \texttt{null} will 
    probably look familiar to you from most any object-oriented language. \texttt{undefined} might 
    be new to you. We'll explore these types in greater detail (and see why they're very different 
    from the other primitives) once we've dug deeper into the type system. For now, just put them on 
    your radar.
    
    It's important to note that the line between primitive and object is not so clearly defined
    in JavaScript as it is in other languages. You'll find that nearly any value in JavaScript can
    \emph{behave} like an object while remaining primitive. Some people interpret this to mean that
    \emph{every value} in JavaScript is an object in disguise, but this is not strictly the case.
    We'll look at objects very closely soon enough.
    
    \subsection{The \texttt{boolean} Datatype}
    If we restrict ourselves to the fundamentals of the type system, the \texttt{boolean} 
    datatype is as simple as can be. The ECMAScript standard explains it in a single sentence:
    
    \begin{quote}
        The Boolean type represents a logical entity having two values, called \textbf{true}
        and \textbf{false}.
    \end{quote}
    
    In practice, \texttt{true} and \texttt{false} are keywords which  statically refer to the two 
    possible boolean values (just as you find in most programming languages). These are considered 
    ``Boolean Literals.''
    
    \subsection{The \texttt{number} Datatype}
    In JavaScript, there is no distinction between integral and floating-point numbers. Instead, 
    we're given a single, unified type: \texttt{number}.
    
    A number is stored as a signed 64-bit float according to the IEEE 754 standard. This means, 
    under the covers, the numbers you deal with in JavaScript have the same encoding constraints as 
    double-precision floats in Java or C.
    
    It is worth noting that the simplicity you get by having a unified type for numbers comes at 
    a cost of space-efficiency, performance and type-safety. On the other hand this will make 
    some of your code cleaner because you will no-longer need no coerce integers to floats or 
    worry about loss of precision in mixed-mode division. In general, we will find that 
    JavaScript tends to sacrifice efficiency/performance/safety in small ways in order to gain 
    in simplicity.
    
    A JavaScript number can be as large as $\pm 1.7976931348623157 \times 10^{308}$ or as small as
    $\pm 5 \times 10^{-324}$. The range of integral values which can be stored in a JavaScript 
    \texttt{number} is $\pm 2^{53}$.
    
    Numbers can be declared with number literals. Number literals are usually decimal (base-10) but 
    can also be hexadecimal (base-16) using the traditional \texttt{0x} prefix. (In some 
    implementations octal (base-8) number literals are allowed when the number is prefixed with a 
    leading zero, although this is not standard.)
    
    \begin{verbatim}
        7
    
        42
        
        7.62
        
        0xf0
    
        0xff63ba
    \end{verbatim}
    
    Number literals can also be written in exponential notation by suffixing a lower or upper-case 
    letter ``e'' followed by a positive or negative radix. 
    
    \begin{verbatim}
    6.022141e23
    
    6.6260695729E-34
    \end{verbatim}
    
    Negative number literals can be made in the usual way, by prefixing the literal with a minus 
    sign. However, this isn't actually part of the literal itself, but is an application of the 
    unary negation operator to the literal.
    
    \begin{verbatim}
    -532
    \end{verbatim}
    
    \subsection{The \texttt{string} Datatype}
    JavaScript provides \texttt{string} as a primitive type for dealing with text. All strings in 
    JavaScript are encoded using UTF-16.
    
    You just learned that JavaScript unifies integers and floats under numbers at a cost of 
    performance and for the sake of simplicity. With strings, JavaScript makes a similar 
    simplification: there is no \texttt{char} type. That is to say: in JavaScript any single 
    character is of type \texttt{string} with a string-length of 1. As a result, when dealing with  
    text, the \texttt{string} datatype is the only datatype you need.
    
    String literals must be delimited by matching single or double quotes. In other words, strings 
    may be delimited by either a matching start and end single quote or a matching start and end 
    double quote but not mixed. The quote type which is not used to delimit may be used within the 
    string literal without escaping.
    
    \begin{verbatim}
    "Hello, world."
    
    'Hello, world with single quotes.'
    
    "This apostrophe needn't be escaped."
    
    'Double "quotes inside single" quotes.'
    \end{verbatim}
    
    JavaScript \texttt{string}s support many of the escape sequences you're used to.
    
    \vspace{10pt}
    \begin{tabular}{l|l|l}
        Sequence & Result \\
        \hline
        \texttt{\textbackslash{'}}  & A single quote. & \textbackslash{u0027} \\
        \texttt{\textbackslash{"}}  & A double quote. & \textbackslash{u0022} \\
        \texttt{\textbackslash\textbackslash} 
                                    & A backslash. & \textbackslash{u005c} \\
        \texttt{\textbackslash{u\#\#\#\#}}
                                    & The unicode character represented by the hexadecimal
                                        digits \#\#\#\#. & \\
        \texttt{\textbackslash{t}}  & A horizontal tab. & \textbackslash{u0009} \\
        \texttt{\textbackslash{n}}  & A newline. & \textbackslash{u000a} \\
    \end{tabular}
    \vspace{10pt}
    
    Several other escape sequences are available, but are not useful in most JavaScript scenarios. 
    A full list of available escape sequences can be found in the appendix.
    
    \begin{verbatim}
    'This apostrophe\'s escape is necessary.'
    
    "Text\n spanning\n multiple\n lines"
    \end{verbatim}
    
    \subsection{The \texttt{object} Datatype}
    
    As stated above, the \texttt{object} datatype may be thought of as a composite of other 
    datatypes. In particular, an object is a collection of \emph{named data properties}, similar
    to a dictionary you may be familiar with from other languages.
    
    It is a remarkable feature of JavaScript that the \texttt{object} datatype also has a literal
    notation. The \texttt{object} is delimited by a pair of curly braces (i.e. ``\texttt{\{}'' and 
    ``\texttt{\}}''). Within these braces, any number of named data properties are specified by a 
    name, followed by a colon (i.e. \texttt{:}) followed by the property's data value. These named 
    data properties must be separated by commas.
    
    As an example, the following is an object literal with two properties: a property named 
    \texttt{foo} with the value of the \texttt{number} \texttt{42} and another property named 
    \texttt{bar} with the value of the \texttt{string} \texttt{"hello, world"}.
    
    \begin{verbatim}
    { foo:42, bar:"hello, world" }
    \end{verbatim}
    
    The order of the properties within the object literal is insignificant because the properties
    will be accessed by their names. For example, if this object were stored in the variable 
    \texttt{x}, the \texttt{foo} property could be accessed via the familiar \emph{dot-notation}.
    
    \begin{verbatim}
    x.foo
    \end{verbatim}
    
    There is an additional \emph{bracket-notation} for accessing properties by a string for their 
    name. The following example accesses the same property as the example above, but with the 
    alternate notation.
    
    \begin{verbatim}
    x["foo"]
    \end{verbatim}
    
    At this point objects may feel significantly similar to a conventional dictionary collection;
    string-keys map to values. This bracket-notation makes two big things possible. First: it allows 
    you to access properties of an object dynamically, via a string variable. Later on, we'll loop
    over the properties of an object by enumerating it's property names into a key variable, and 
    then access the property values themselves by using that key variable with the bracket-notation.
    
    Secondly, the bracket-notation makes possible the accessing of properties which have names with 
    symbols that are not valid in normal property names. For example, it is a single property named 
    \texttt{prop.erty} cannot be accessed using the dot notation because the dot in its name will be
    misinterpreted as accessing the \texttt{erty} subproperty of the \texttt{prop} property. Instead
    we can access this value in the following manner.
    
    \begin{verbatim}
    x["prop.erty"]
    \end{verbatim}
    
    As you can see, because the dot is safely enclosed within the string, JavaScript can see that it 
    is the name of a single property.
    
    The \texttt{object literal} syntax also allows illegal symbols in property names if you write
    the property name as a string. For example:
    
    \begin{verbatim}
    { "name with spaces":"hello, world", "(){}[]":"another value" }
    \end{verbatim}
    
    You may notice that all of these bracket-notation examples use strings as keys, and may wonder
    whether other datatypes may be used for property names. The answer is yes, sortof. We'll explore 
    the use of non-strings as property indexers when we take a much deeper look at the object 
    datatype.
    
    So far we've dealt with objects using the object literal syntax, but all objects can also be 
    created using another syntax which may be familiar to you: using the \texttt{new} operator and 
    the object constructor. Par example:
    
    \begin{verbatim}
    new Object();
    \end{verbatim}
    
    The reader's inner object-oriented programmer may immediately identify \texttt{Object} (with the 
    initial capital) as the \emph{class} of objects, but this is wrong. When we explore 
    object-orientation in later chapters we'll see that \texttt{Object} is not the \emph{class}, but 
    merely the \emph{constructor} for the \texttt{object} datatype.
    
    \section{Built-in Objects}
    It may seem odd that we discuss the four fundamental datatypes while not looking at arrays.
    Often, arrays are their own separate, special datatype, like in C. However, in JavaScript the 
    \emph{array datatype is implemented as an object}. More importantly, arrays are implemented are 
    \emph{built-in objects}.
    
    Built-in-objects are from a set of classes which are provided for you by the JavaScript 
    implementation. Often, these objects are implemented with \emph{native code} and are part of 
    the JavaScript runtime itself. (Put differently, they are JavaScript objects which are not 
    written in JavaScript.) Consequently, they will behave a little differently from the objects 
    that you create.
    
    \subsection{The \texttt{array} Datatype}
    
    The array datatype is a good first example of a built-in-object. In JavaScript, arrays are 
    one-dimensional, untyped (potentially heterogenous) and dynamically expanding. 
    
    We can create an empty array with the array literal syntax. The array is delimited by a pair of 
    open and close square braces (i.e. ``\texttt{[}'' and ``\texttt{]}'') and between them the 
    elements are separated by commas.
    
    \begin{verbatim}
    [ "element 1", "element 2", "element 3" ]
    \end{verbatim}
    
    Because arrays are really a kind of object, we can also build one with the constructor synatx:
    
    \begin{verbatim}
    new Array()
    \end{verbatim}
    
    There are two additionnal ways to call the array constructor. It can be called with a single 
    \texttt{number} argument to tell the runtime how many spaces to pre-allocate. Although a 
    pre-allocated array will have the specified length, it will otherwise behave like an empty array
    as it does not have any elements for the allocated spaces.
    
    \begin{verbatim}
    new Array(5)
    
    new Array(12)
    \end{verbatim}
    
    Aa another way, the \texttt{Array} constructor can be called as a variadic function with all of 
    the elements with which pre-populate the array.
    
    \begin{verbatim}
    new Array("element 1", "element 2", "element 3");
    
    new Array(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987);
    \end{verbatim}
    
    You may notice that there is a potential ambiguity between these two argument patterns: if the
    \texttt{array} constructor is called as a variadic with only a single argument, will the
    constructor treat that argument as only element or as the given length of the new array? The 
    resolution to this issue is that the constructor tests whether that single argument is an 
    integral \texttt{number}, in which case it will be used as the array's new length but not as its 
    element. In all other cases, that argument will be used as the lone element of the array (which 
    will then have a length of one). 
    
    Because of this ambiguity, most programmers avoid the variadic version of the constructor and 
    instead use the object literal.
    
    The elements of any array can be indexed using the same bracket notation for accessing 
    properties of objects. The only difference being that instead of passing the \texttt{string} of 
    the name of the property, we pass the inegral \texttt{number} of the element's zero-based index.
    For example, the following illustrates how to access the first and the twelfth element of an 
    array named \texttt{foo}.
    
    \begin{verbatim}
    foo[0]
    
    foo[11]
    \end{verbatim}
    
    
    
\end{document}








