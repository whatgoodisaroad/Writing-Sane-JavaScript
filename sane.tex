\documentclass[11pt,letter]{book}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\usepackage[pdftex]{graphicx}

\begin{document}
    \frontmatter

    \begin{titlepage}
        \begin{center}
            { \huge \bfseries Writing Sane JavaScript}\\[0.4cm]
            \textsc{\Large A Comprehensive Introduction}\\[0.5cm]
            \textsc{Wyatt Allen}
            \HRule \\[1.2cm]
            \includegraphics[width=10cm]{socrates-hemlock}
            \vfill
        \end{center}
    \end{titlepage}
    
    \tableofcontents 
    
    \chapter{Introduction}
    \begin{quote}
        \emph{
            ... An interesting mix ... capable of such beautiful dreams and such horrible 
            nightmares.
        }
    \end{quote}
    \begin{flushright}
        -- Carl Sagan, \emph{Contact}
    \end{flushright}
    \HRule \\[1.2cm]
    
    JavaScript is a truly remarkable language. It is ubiquitous: every computer with a browser 
    installed comes with a full runtime. It's uncommonly powerful: its dynamic nature is more 
    flexible than nearly any enterprise language, yet is used to do more and more amazing things.
    It's unstoppable: since its halfhearted genesis in 1995 it's never slowed its growing 
    popularity.
    
    Moreover, JavaScript is simultaneously beautiful and deeply flawed. The above quote from Carl 
    Sagan frequently visits my thoughts as I work on code, although it was originally written about 
    an alien being musing on the human race. There's no shortage of JavaScript code which is truly 
    beautiful and elegant, frequently leaving the programmer with the impression of that 
    ever-indefinable language quality: \emph{expressiveness}.
    
    But much more frequently, JavaScript will leave the programmer with a strong, sour impression of 
    a desperate mess. Unreadable, unreliable, buggy and just plain bad code is rampant and difficult 
    for the professional programmer to avoid encountering (or even to avoid writing, sometimes).
    
    Bad JavaScript code doesn't necessarily mean bad programmers. It's a product of haphazard 
    language design. For all of JavaScript's flexibility and power it can sometimes be maddeningly 
    inconsistent and idiosyncratic, especially to the beginner. The aim of this book is to lend you, 
    the reader complete knowledge of this unusual and rewarding language in order to overcome its 
    obstacles. To wax just a bit starry-eyed, the aim of this book is to prevent the horrible 
    nightmares, and promote the beautiful dreams.
    
    \section*{Pedagogy}
    Learning to master JavaScript is an unusual challenge when compared to the task of learning 
    other programming languages. No small part of this challenge is the fact that it's a very easy 
    language to pick up and start using in a basic way without formally learning it. Just about any 
    programmer with an acquaintance with the C family of languages could hack together a functioning
    event handler or popup in a webpage by trial and error or a handful of Google searches.
    
    Because JavaScript is so easy to mess with, and is often used as a afterthought in webpage 
    design, many treat it like a toy language and percieve formally learing it to be overkill. 
    Unstoppably, however, JavaScript's role in the web has become more and more central. Scripts 
    have grown to be complex and archetected -- no longer simple, shallow event handlers but real, 
    multi-tier applications. The casual knowledge a programmer may gain from simple script hacking
    becomes insufficient for constructing these new, complex, engineered systems.
    
    This book was written to give you, the reader a proper, formal understanding of this capable 
    language. For this reason, we do not begin with the easy aspects of the language; we will start 
    by delving into the language's hard parts. At no point in this book will we treat JavaScript as
    a toy language. 
    
    Many other JavaScript books will begin with the easier, more casual aspects of the language, 
    forcing readers to make a paradigm-shift partway through before they can really, formally learn.
    Other books focus exclusively on the good parts of the language, advising readers to avoid using 
    (or even considering) the poorly-designed parts which can cause trouble. Still other books are 
    dry and meticulous tomes which, while useful reference volumes, afford little to the learner.
    
    In this book, we will make an unflinching, complete tour of JavaScript. After reading, you, the 
    reader will be able to say that you know or grok the language, warts and all. Moreover, 
    the power is given to you the reader throughout these chapters to judge the language. I will 
    always endeavor to advise you on the common snags, but, as a programmer, your judgement is 
    respected and you choose what to make of it all.
    
    \section*{Who Is this Book For?}
    As stated above, in this book, the power is given to you the reader \emph{as a programmer}. 
    Consequently, you will need to be able to program. This is not an introduction to programming 
    via JavaScript, but a comprehensive introduction to JavaScript programming. No prior 
    JavaScript knowledge will be assumed.
    
    As we shall see in JavaScript's history, its language design is influenced by C, Java and 
    (remarkably) Self. If the reader is acquainted with any of these, it will be a great help. At 
    least some understanding of Object-Oriented Programming (OOP) will be requisite, although 
    JavaScript may force you to un-learn some of OOP's traditional forms. Acquaintance with 
    Functional Progamming (FP) will be helpful for understanding much of JavaScript, but is not 
    necessary.
    
    \section*{History}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    TODO: Title, History, Significance, Beauty, State, How to read
    
    \mainmatter
    
    \part{The Language}
    \chapter{The Type System}
    \section{Overview}
    The key to mastering JavaScript is a complete understanding of the type system. In this chapter
    we will have a first look at each of the fundamental datatypes in JavaScript. We examine the 
    type system before presenting any code examples, so this chapter may seem a little dry. Let the 
    reader be ensured, however, that this approach is to provide a rich context for when we finally
    do get to code.
    
    JavaScript has a unique type system. In many ways it is Spartan. In many other ways 
    it is rich and expressive. In many, many other ways it is inconsistent and treacherous.
    Throughout this book, you will be introduced to the type system from each of these three 
    angles.
    
    If you, the reader, gain a complete understanding of these types, it will either result 
    in true enjoyment of a unique and powerful system, or well-informed hatred of a tangled 
    mess. Read on to find out which it will be.
    
    \section{Datatypes at a Fundamental Level}
    At a fundamental level JavaScript has four basic datatypes. There are three primitive 
    types which should be familiar to you as a programmer: \texttt{boolean}, \texttt{number} 
    and \texttt{string}. The fourth datatype is \texttt{object}, which may be thought of as a 
    composite type. The three primitives will behave largely in a similar fashion to what you're 
    used to in other languages, but some of \texttt{object}'s nuances may be surprising.
    
    Although we say there are only three primitive datatypes, JavaScript technically defines two 
    more: \texttt{null} and \texttt{undefined}. \texttt{null} will probably look familiar to you 
    from most any object-oriented language. \texttt{undefined} might be new to you. We'll explore 
    these types in greater detail (and see why they're very different from the other primitives) 
    once we've dug deeper into the type system. For now, just put them on your radar.
    
    It's important to note that the line between primitive and object is not so clearly defined
    in JavaScript as it is in other languages. You'll find that nearly any value in JavaScript can
    \emph{behave} like an object while remaining primitive. Some people interpret this to mean that
    \emph{every value} in JavaScript is an object in disguise, but this is not strictly the case.
    We'll look at objects very closely soon enough.
    
    \subsection{The \texttt{boolean} Datatype}
    If we restrict ourselves to the fundamentals of the type system, the \texttt{boolean} 
    datatype is as simple as can be. The ECMAScript standard explains it in a single sentence:
    
    \begin{quote}
        The Boolean type represents a logical entity having two values, called \textbf{true}
        and \textbf{false}.
    \end{quote}
    
    In practice, \texttt{true} and \texttt{false} are keywords which  statically refer to the two 
    possible boolean values (just as you find in most programming languages). These are considered 
    ``Boolean Literals.''
    
    \subsection{The \texttt{number} Datatype}
    In JavaScript, there is no distinction between integral and floating-point numbers. Instead, 
    we're given a single, unified type: \texttt{number}.
    
    A number is stored as a signed 64-bit float according to the IEEE 754 standard. This means, 
    under the covers, the numbers you deal with in JavaScript have the same encoding constraints as 
    double-precision floats in Java or C.
    
    It is worth noting that the simplicity you get by having a unified type for numbers comes at 
    a cost of space-efficiency, performance and type-safety. On the other hand this will make 
    some of your code cleaner because you will no-longer need no coerce integers to floats or 
    worry about loss of precision in mixed-mode division. In general, we will find that 
    JavaScript tends to sacrifice efficiency/performance/safety in small ways in order to gain 
    in simplicity.
    
    A JavaScript number can be as large as $\pm 1.7976931348623157 \times 10^{308}$ or as small as
    $\pm 5 \times 10^{-324}$. The range of integral values which can be stored in a JavaScript 
    \texttt{number} is $\pm 2^{53}$.
    
    Numbers can be declared with number literals. Number literals are usually decimal (base-10) but 
    can also be hexadecimal (base-16) using the traditional \texttt{0x} prefix. (In some 
    implementations octal (base-8) number literals are allowed when the number is prefixed with a 
    leading zero, although this is not standard.)
    
    \begin{verbatim}
        7
    
        42
        
        7.62
        
        0xf0
    
        0xff63ba
    \end{verbatim}
    
    Number literals can also be written in exponential notation by suffixing a lower or upper-case 
    letter ``e'' followed by a positive or negative radix. 
    
    \begin{verbatim}
    6.022141e23
    
    6.6260695729E-34
    \end{verbatim}
    
    Negative number literals can be made in the usual way, by prefixing the literal with a minus 
    sign. However, this isn't actually part of the literal itself, but is an application of the 
    unary negation operator to the literal.
    
    \begin{verbatim}
    -532
    \end{verbatim}
    
    \subsection{The \texttt{string} Datatype}
    JavaScript provides \texttt{string} as a primitive type for dealing with text. All strings in 
    JavaScript are encoded using UTF-16.
    
    You just learned that JavaScript unifies integers and floats under numbers at a cost of 
    performance and for the sake of simplicity. With strings, JavaScript makes a similar 
    simplification: there is no \texttt{char} type. That is to say: in JavaScript any single 
    character is of type \texttt{string} with a string-length of 1. As a result, when dealing with  
    text, the \texttt{string} datatype is the only datatype you need.
    
    String literals must be delimited by matching single or double quotes. In other words, strings 
    may be delimited by either a matching start and end single quote or a matching start and end 
    double quote but not mixed. The quote type which is not used to delimit may be used within the 
    string literal without escaping.
    
    \begin{verbatim}
    "Hello, world."
    
    'Hello, world with single quotes.'
    
    "This apostrophe needn't be escaped."
    
    'Double "quotes inside single" quotes.'
    \end{verbatim}
    
    JavaScript \texttt{string}s support many of the escape sequences you're used to.
    
    \vspace{10pt}
    \begin{tabular}{l|l|l}
        Sequence & Result & Code-Point \\
        \hline
        \texttt{\textbackslash{'}}  & A single quote. & \textbackslash{u0027} \\
        \texttt{\textbackslash{"}}  & A double quote. & \textbackslash{u0022} \\
        \texttt{\textbackslash\textbackslash} 
                                    & A backslash. & \textbackslash{u005c} \\
        \texttt{\textbackslash{u\#\#\#\#}}
                                    & The unicode character represented by the hexadecimal
                                        digits \#\#\#\#. & \\
        \texttt{\textbackslash{t}}  & A horizontal tab. & \textbackslash{u0009} \\
        \texttt{\textbackslash{n}}  & A newline. & \textbackslash{u000a} \\
    \end{tabular}
    \vspace{10pt}
    
    Several other escape sequences are available, but are not useful in most JavaScript scenarios. 
    A full list of available escape sequences can be found in the appendix.
    
    \begin{verbatim}
    'This apostrophe\'s escape is necessary.'
    
    "Text\n spanning\n multiple\n lines"
    \end{verbatim}
    
    \subsection{The \texttt{object} Datatype}
    
    As stated above, the \texttt{object} datatype may be thought of as a composite of other 
    datatypes. In particular, an object is a collection of \emph{named data properties}, similar
    to a dictionary you may be familiar with from other languages.
    
    It is a remarkable feature of JavaScript that the \texttt{object} datatype also has a literal
    notation. The \texttt{object} is delimited by a pair of curly braces (i.e. ``\texttt{\{}'' and 
    ``\texttt{\}}''). Within these braces, any number of named data properties are specified by a 
    name, followed by a colon (i.e. \texttt{:}) followed by the property's data value. These named 
    data properties must be separated by commas.
    
    As an example, the following is an object literal with two properties: a property named 
    \texttt{foo} with the value of the \texttt{number} \texttt{42} and another property named 
    \texttt{bar} with the value of the \texttt{string} \texttt{"hello, world"}.
    
    \begin{verbatim}
    { foo:42, bar:"hello, world" }
    \end{verbatim}
    
    The order of the properties within the object literal is insignificant because the properties
    will be accessed by their names. For example, if this object were stored in the variable 
    \texttt{x}, the \texttt{foo} property could be accessed via the familiar \emph{dot-notation}.
    
    \begin{verbatim}
    x.foo
    \end{verbatim}
    
    There is an additional \emph{bracket-notation} for accessing properties by a string for their 
    name. The following example accesses the same property as the example above, but with the 
    alternate notation.
    
    \begin{verbatim}
    x["foo"]
    \end{verbatim}
    
    At this point objects may feel significantly similar to a conventional dictionary collection;
    string-keys map to values. This bracket-notation makes two big things possible. First: it allows 
    you to access properties of an object dynamically, via a string variable. Later on, we'll loop
    over the properties of an object by enumerating it's property names into a key variable, and 
    then access the property values themselves by using that key variable with the bracket-notation.
    
    Secondly, the bracket-notation makes possible the accessing of properties which have names with 
    symbols that are not valid in normal property names. For example, it is a single property named 
    \texttt{prop.erty} cannot be accessed using the dot notation because the dot in its name will be
    misinterpreted as accessing the \texttt{erty} subproperty of the \texttt{prop} property. Instead
    we can access this value in the following manner.
    
    \begin{verbatim}
    x["prop.erty"]
    \end{verbatim}
    
    As you can see, because the dot is safely enclosed within the string, JavaScript can see that it 
    is the name of a single property.
    
    The \texttt{object literal} syntax also allows illegal symbols in property names if you write
    the property name as a string. For example:
    
    \begin{verbatim}
    { "name with spaces":"hello, world", "(){}[]":"another value" }
    \end{verbatim}
    
    You may notice that all of these bracket-notation examples use strings as keys, and may wonder
    whether other datatypes may be used for property names. The answer is yes, sortof. We'll explore 
    the use of non-strings as property indexers when we take a much deeper look at the object 
    datatype.
    
    So far we've dealt with objects using the object literal syntax, but all objects can also be 
    created using another syntax which may be familiar to you: using the \texttt{new} operator and 
    the object constructor. Par example:
    
    \begin{verbatim}
    new Object()
    \end{verbatim}
    
    The reader's inner object-oriented programmer may immediately identify \texttt{Object} (with the 
    initial capital) as the \emph{class} of objects, but this is wrong. When we explore 
    object-orientation in later chapters we'll see that \texttt{Object} is not the \emph{class}, but 
    merely the \emph{constructor} for the \texttt{object} datatype.
    
    \section{Built-in Objects}
    It may seem odd that we discuss the four fundamental datatypes while not looking at arrays.
    Often, arrays are their own separate, special datatype, like in C. However, in JavaScript the 
    \emph{array datatype is implemented as an object}. More importantly, arrays are an example of 
    \emph{built-in objects}.
    
    Built-in-objects are from a set of classes which are provided for you by the JavaScript 
    implementation. Often, these objects are implemented with \emph{native code} and are part of 
    the JavaScript runtime itself. (Put differently, they are JavaScript objects which are not 
    written in JavaScript.) Consequently, they will behave a little differently from the objects 
    that you create.
    
    \subsection{The \texttt{array} Datatype}
    
    The array datatype is a good first example of a built-in-object because it is so useful. In 
    JavaScript, arrays are one-dimensional, untyped (potentially heterogenous) and dynamically 
    expanding. 
    
    We can create an empty array with the array literal syntax. The array is delimited by a pair of 
    open and close square braces (i.e. ``\texttt{[}'' and ``\texttt{]}'') and between them the 
    elements are separated by commas.
    
    \begin{verbatim}
    [ "element 1", "element 2", "element 3" ]
    \end{verbatim}
    
    Because arrays are really a kind of object, we can also build one with the constructor synatx:
    
    \begin{verbatim}
    new Array()
    \end{verbatim}
    
    There are two additionnal ways to call the array constructor. It can be called with a single 
    \texttt{number} argument to tell the runtime how many spaces to pre-allocate. Although a 
    pre-allocated array will have the specified length, it will otherwise behave like an empty array
    as it does not have any elements for the allocated spaces.
    
    \begin{verbatim}
    new Array(5)
    
    new Array(12)
    \end{verbatim}
    
    Aa another way, the \texttt{Array} constructor can be called as a variadic function with all of 
    the elements with which pre-populate the array.
    
    \begin{verbatim}
    new Array("element 1", "element 2", "element 3");
    
    new Array(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987);
    \end{verbatim}
    
    You may notice that there is a potential ambiguity between these two argument patterns: if the
    \texttt{array} constructor is called as a variadic with only a single argument, will the
    constructor treat that argument as only element or as the given length of the new array? The 
    resolution to this issue is that the constructor tests whether that single argument is an 
    integral \texttt{number}, in which case it will be used as the array's new length but not as its 
    element. In all other cases, that argument will be used as the lone element of the array (which 
    will then have a length of one). 
    
    Because of this ambiguity, most programmers avoid the variadic version of the constructor and 
    instead use the array literal.
    
    The elements of any array can be indexed using the same bracket notation for accessing 
    properties of objects. The only difference being that instead of passing the \texttt{string} of 
    the name of the property, we pass the inegral \texttt{number} of the element's zero-based index.
    For example, the following illustrates how to access the first and the twelfth element of an 
    array named \texttt{foo}.
    
    \begin{verbatim}
    foo[0]
    
    foo[11]
    \end{verbatim}
    
    \subsection{Other Built-in-Objects}
    JavaScript provides a whole host of useful built-in types in addition \texttt{array}. For 
    example, JavaScript provides a complete regular expression datatype called \texttt{RegExp} which
    has a literal syntax of its own. JavaScript provieds a \texttt{Date} object for parsing and 
    managing dates and times. The behemoth that is JavaScript's DOM API provides a huge amount of 
    built-in objects to represent the various components of a webpage.
    
    In the next chapter we'll learn about control structures and find that \emph{functions 
    themselves} are buit-in objects. This is a big concept, and we'll devote a lot of pages to them,
    but it means \texttt{function} is just another datatype. It can be stored to a variable or 
    passed as an argument.
    
    For the sake of this preliminary look at the type system, we'll have to leave off a complete 
    investigation of these built-in object datatypes for later chapters. Each type has its own 
    unique nuances, niceties and annoyances, so we'll have to take our time in order to be complete.
    
    \chapter{Procedural Programming}
    Now that we've got a blah blah blah
    
\end{document}













